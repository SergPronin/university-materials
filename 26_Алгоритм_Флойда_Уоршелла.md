# 26. Алгоритм Флойда–Уоршелла

[[25_Алгоритм_Беллмана_Форда|← Предыдущий билет]] | [[27_Алгоритм_Прима|→ Следующий билет]]

---

## 📌 Назначение

**Алгоритм Флойда–Уоршелла** находит кратчайшие расстояния между **всеми парами вершин** во взвешенном ориентированном графе.

- Поддерживает **отрицательные веса**, но не допускает **отрицательных циклов**
    
- Работает на основе **динамического программирования**
    

---

## 🧠 Идея

- Пусть `dist[i][j]` — кратчайшее расстояние от `i` до `j`
    
- Постепенно улучшаем `dist[i][j]`, если есть путь через промежуточную вершину `k`
    
- Формула:
    

```java
if (dist[i][k] + dist[k][j] < dist[i][j])
    dist[i][j] = dist[i][k] + dist[k][j];
```

---

## 📐 Пошаговое выполнение вручную (пример)

Граф:

```
    A → B (3)
    A → C (10)
    B → C (1)
```

Матрица до начала:

```
      A   B   C
A [   0,  3, 10 ]
B [ INF, 0,  1 ]
C [ INF, INF, 0 ]
```

Промежуточные вершины: K от 0 до 2 (A, B, C)

### k = B:

- A→C можно улучшить через B: 3 + 1 = 4 < 10 → обновим A→C
    

Результат:

```
      A   B   C
A [   0,  3,  4 ]
B [ INF, 0,  1 ]
C [ INF, INF, 0 ]
```

---

## 🧩 Реализация на Java

```java
int[][] dist = new int[V][V];

// Инициализация
for (int i = 0; i < V; i++) {
    for (int j = 0; j < V; j++) {
        if (i == j) dist[i][j] = 0;
        else if (edgeExists(i, j)) dist[i][j] = weight(i, j);
        else dist[i][j] = INF;
    }
}

// Основной алгоритм
for (int k = 0; k < V; k++) {
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            if (dist[i][k] + dist[k][j] < dist[i][j]) {
                dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
}
```

---

## 📈 Сложность

- Время: **O(V³)**
    
- Память: **O(V²)**
    

---

## ✅ Выводы

- Эффективен для **всех пар вершин**, когда граф небольшой
    
- Поддерживает отрицательные веса, но **не работает при отрицательных циклах**
    
- Прост в реализации на матрице
    

---

[[27_Алгоритм_Прима|→ Следующий билет: Алгоритм Прима]]