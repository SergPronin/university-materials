# 05. Быстрая сортировка (Quick Sort)

[[04_Сортировка_Слиянием|← Предыдущий билет]] | [[06_Пирамидальная_сортировка|→ Следующий билет]]

---

## 🧠 Что такое Quick Sort

**Быстрая сортировка** — это один из самых популярных и эффективных алгоритмов сортировки. Он также использует стратегию **«разделяй и властвуй»**, но делает это иначе, чем Merge Sort.

Главная идея:

- выбирается **опорный элемент (pivot)**
    
- массив **разделяется на две части**:
    
    - элементы **меньше** опорного — слева
        
    - элементы **больше** опорного — справа
        
- затем **рекурсивно** сортируются обе части
    

Quick Sort работает **на месте**, то есть **не требует дополнительной памяти** для хранения массивов, и потому часто быстрее Merge Sort на практике.

---

## 🔧 Как работает Quick Sort

1. Выбрать опорный элемент (pivot)
    
2. Разделить массив на 2 части:
    
    - элементы < pivot слева
        
    - элементы > pivot справа
        
3. Применить алгоритм к каждой части рекурсивно
    

> Выбор опоры критически важен — от него зависит производительность. Лучше всего брать **средний элемент** или выбирать случайно.

---

## 📉 Пример пошагово

Массив: `[6, 3, 8, 5, 2, 7, 4, 1]`

1. Выбираем pivot = `6`
    
2. Разделяем: `[3, 5, 2, 4, 1]` | `6` | `[8, 7]`
    
3. Рекурсивно сортируем левую и правую части:
    
    - Слева: pivot = `3`, → `[2, 1] | 3 | [5, 4]`, и т.д.
        

Итог: `[1, 2, 3, 4, 5, 6, 7, 8]`

---

## 🧑‍💻 Java-код реализации

```java
public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }
}
```

---

## 📈 Оценка сложности

|Сценарий|Время|Память|Стабильность|
|---|---|---|---|
|Лучший|O(n log n)|O(log n)|❌ Нет|
|Средний|O(n log n)|O(log n)|❌ Нет|
|Худший|O(n²)|O(log n)|❌ Нет|

➡️ В худшем случае (если каждый раз выбирать минимальный или максимальный элемент как pivot) — производительность падает до `O(n²)`.

---

## 🧩 Особенности

- **Очень быстрый** на практике
    
- Работает **на месте**, без выделения памяти
    
- Не является **стабильным** — порядок одинаковых элементов может нарушаться
    
- Ключевая точка — **выбор pivot** (можно улучшить за счёт рандомизации или медианы трёх)
    

---

## 🔄 Сравнение с Merge Sort

|Свойство|Quick Sort|Merge Sort|
|---|---|---|
|Метод деления|По значению (pivot)|Пополам|
|Объединение|Не требуется|Требуется слияние|
|Память|O(log n) стек вызовов|O(n) дополнительная память|
|Стабильность|❌ Нет|✅ Да|
|Быстродействие|✅ Быстрее на практике|Предсказуемо стабильное|
|Используется для|Примитивов (int[], char[], ...)|Объектов (Object[])|

---

## ✅ Выводы

- Один из самых эффективных алгоритмов сортировки
    
- Быстрее большинства других алгоритмов при хорошем выборе опорного элемента
    
- Требует осторожности при реализации из-за возможных худших случаев
    
- Используется внутри `Arrays.sort()` для примитивных типов в Java
    

---

[[06_Пирамидальная_сортировка|→ Следующий билет: Пирамидальная сортировка (Heap Sort)]]